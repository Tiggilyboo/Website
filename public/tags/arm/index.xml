<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Arm on Simon Willshire</title>
    <link>http://simonwillshire.com/tags/arm/</link>
    <description>Recent content in Arm on Simon Willshire</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Apr 2016 18:16:00 -0500</lastBuildDate>
    <atom:link href="http://simonwillshire.com/tags/arm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Docker Swarm on ARM</title>
      <link>http://simonwillshire.com/blog/Docker-Swarm-ARM-Cluster/</link>
      <pubDate>Fri, 01 Apr 2016 18:16:00 -0500</pubDate>
      
      <guid>http://simonwillshire.com/blog/Docker-Swarm-ARM-Cluster/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/docker/swarm&#34;&gt;
  &lt;img src=&#34;https://github.com/docker/swarm/blob/master/logo.png?raw=true&#34; alt=&#34;Docker Swarm&#34; style=&#34;max-width:100%;&#34;/&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;overview:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;So, a couple years ago when I was studying my bachelors, I did a project for an operating systems course on the ARM big little architecture and scheduling algorithms (You can even read my final paper &lt;a href=&#34;http://simonwillshire.com/files/OS_ARM_Cluster.pdf&#34;&gt;here&lt;/a&gt;). Fast forward a couple years, and I&amp;rsquo;ve still got some ARM boards floating around - After doing some reading into Docker Swarm, I thought I&amp;rsquo;d try it out without virtualizing everything on my main box. This guide documents more or less my steps to create a working swarm&amp;hellip;&lt;/p&gt;

&lt;p&gt;First off, this guide assumes that all nodes are,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Networked, and have been identified by hostnames, and have SSH keys set up: recommend using a fairly fast but cheap backbone, like GB ethernet.&lt;/li&gt;
&lt;li&gt;ARM arch of course&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tl-dr-just-give-me-the-tar-s:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;TL;DR; Just give me the tar&amp;rsquo;s!&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker Machine 0.4.1 Linux ARMv7 &lt;strong&gt;&lt;a href=&#34;https://bitbucket.org/tiggilyboo/website/downloads/docker-machine.0.4.1.tar.gz&#34;&gt;tar.gz&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Go 1.4.3 Linux ARMv7 (Bootstrap to build 1.5.2) &lt;strong&gt;&lt;a href=&#34;https://bitbucket.org/tiggilyboo/website/downloads/go1.4.3.linux-armv7.tar.gz&#34;&gt;tar.gz&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Go 1.5.2 Linux ARMv7 (To build Docker Swarm) &lt;strong&gt;&lt;a href=&#34;https://bitbucket.org/tiggilyboo/website/downloads/go1.5.2.linux-armv7.tar.gz&#34;&gt;tar.gz&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Docker Swarm Linux ARMv7 Container &lt;strong&gt;&lt;a href=&#34;https://bitbucket.org/tiggilyboo/website/downloads/swarm.linux-armv7.tar.gz&#34;&gt;tar.gz&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Docker Alpine Linux ARMv7 Image &lt;strong&gt;&lt;a href=&#34;https://bitbucket.org/tiggilyboo/website/downloads/alpine.linux-armv7.tar.gz&#34;&gt;tar.gz&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once you&amp;rsquo;ve got docker running, you may pull directly from dockerhub; the Hypriot packages should work (Build for Raspberry Pi&amp;rsquo;s).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker pull hypriot/rpi-swarm
$ docker pull hypriot/rpi-alpine-scratch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;guide:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Guide&lt;/h2&gt;

&lt;p&gt;Here are the steps I took to set up an ARMv7 cluster using &lt;a href=&#34;https://github.com/docker/swarm&#34;&gt;Docker Swarm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;http://www.hardkernel.com/main/products/prdt_info.php?g_code=g138745696275&#34;&gt;ODroid U3&amp;rsquo;s&lt;/a&gt; for this example, which have the necessary kernel flags set to properly run Docker. To check if your kernel has the required flags, run the following before going any further:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -L https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh | /bin/bash /dev/stdin /path/to/.config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Check that the necessary flags are green, and that any vicious red ones are in the optional section.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;installing-docker:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Installing Docker&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ apt-get install lxc aufs-tools cgroup-lite apparmor docker.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;arm-docker-images:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;ARM Docker Images&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve used &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-alpine-scratch/&#34;&gt;this alpine&lt;/a&gt; armhf image for my containers. However, you can find your own using: &lt;code&gt;docker search armhf-&lt;/code&gt;, or &lt;code&gt;docker search hypriot&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and then pull the one you like, and test that it runs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker pull hypriot/rpi-alpine-scratch
$ docker run --rm hypriot/rpi-alpine-scratch echo &#39;image works!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;leader-nfs-for-images-containers-optional:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Leader NFS for Images &amp;amp; Containers (Optional)&lt;/h3&gt;

&lt;p&gt;Since the ARM boards typically do not have much storage capacity and typically are running on slow class 10 SD cards, I&amp;rsquo;ve decided to run the leader node attached to a SSD.&lt;/p&gt;

&lt;h4 id=&#34;ssd-host-on-leader-node:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;SSD Host on leader node&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ apt-get install nfs-kernel-server
$ nano /etc/exports
$ nano /etc/fstab
$ mount -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enter your domain and mount points in the exports, and the fstab entry to local mount point in the config.&lt;/p&gt;

&lt;h4 id=&#34;client-node-nfs-mount:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Client Node NFS mount&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ apt-get install nfs-common
$ showmount -e &amp;lt;ip/hostname of leader&amp;gt;
$ nano /etc/fstab
$ mount -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensure the leader nodes nfs is visible, then enter the fstab entry with the &amp;lsquo;nfs&amp;rsquo; storage type.&lt;/p&gt;

&lt;p&gt;Now you should be able to use the -v flag when using docker images/containers; but make sure to only use one image per node.&lt;/p&gt;

&lt;h3 id=&#34;building-docker-swarm:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Building Docker Swarm&lt;/h3&gt;

&lt;p&gt;Since Docker Swarm does not have any ARM builds, we have to build it from source. It requires Golang 1.4 and later, so let&amp;rsquo;s set that up&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;build-golang-1-4-to-bootstrap-golang-1-5:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Build Golang 1.4 to bootstrap Golang 1.5&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ apt-get remove golang
$ rm -fr /usr/local/go
$ curl -O https://storage.googleapis.com/golang/go1.4.3.src.tar.gz
$ tar -xzf go1.4.3.src.tar.gz -C /usr/local go
$ mv /usr/local/go /usr/local/go1.4
$ cd /usr/local/go1.4/src
$ time sudo ./make.bash
$ tar --numeric-owner -czf ~/go1.4.3.linux-armv7.tar.gz -C /usr/local go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may take some time depending on your board&amp;rsquo;s performance (The odroid U3&amp;rsquo;s took roughly 3.5 minutes)&amp;hellip; Next up, we package go into a tarball, and use it to bootstrap golang 1.5.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rm -rf /usr/share/go
$ tar -xzf ~/go1.4.3.linux-armv7.tar.gz -C ~/go1.4 --strip-components=1
$ curl -sSL https://storage.googleapis.com/golang/go1.5.2.src.tar.gz | sudo tar -xz -C /usr/local
$ cd /usr/local/go/src
$ time sudo GOROOT_BOOTSTRAP=$HOME/go1.4 ./make.bash
$ tar --numeric-owner -czf ~/go1.5.2.linux-armv7.tar.gz -C /usr/local go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Pheeeeww&lt;/em&gt;, we now have Go 1.5 to build Docker Swarm. Just install it like normal go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rm -fr /usr/local/go
$ tar -xzf ~/go1.5.2.linux-armv7.tar.gz -C /usr/local
$ export PATH=$PATH:/usr/local/go/bin
$ go version
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;build-docker-swarm-finally:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Build Docker Swarm (Finally!)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get github.com/tools/godep
$ mkdir -p ~/go/src/github.com/docker
$ cd ~/go/src/github.com/docker/
$ git clone https://github.com/docker/swarm
$ cd swarm
$ ~/go/bin/godep go install -v -a -tags netgo -installsuffix netgo -ldflags &#39;-extldflags &amp;quot;static&amp;quot; -s&#39; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should spit out a swarm binary at &lt;code&gt;~/go/bin/swarm&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;deploy-docker-swarm-to-all-nodes:7b87414412943d6a0b6ea0bb7b04d1ba&#34;&gt;Deploy Docker Swarm To All Nodes&lt;/h4&gt;

&lt;p&gt;Now that we have Docker Swarm built, we need to install in on each of our nodes. What better way to do this that create a Dockerfile! Create a new file at &lt;code&gt;~/go/bin/Dockerfile&lt;/code&gt; with the following contents:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM cratch
COPY ./swarm /swarm
ENV SWARM_HOST :2375
EXPOSE 2375
VOLUME $HOME/.swarm

ENTRYPOINT [&amp;quot;/swarm&amp;quot;]
CMD [&amp;quot;--help&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you are confused as to what this does, check out the official &lt;strong&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;Dockerfile reference&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now package it up, and send it to each of your nodes. If you set up an NFS drive for your cluster, you could use it as a central access point for Docker data should you be worried about image/container storage (It gets huge, especially on small capacity SD cards).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/go/bin
docker build -t swarm:latest .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can then commit and push this package up to dockerhub or github or what have you. &lt;em&gt;Just make sure you don&amp;rsquo;t pull down the default &amp;lsquo;swarm&amp;rsquo; package, as it will make your ARM board question its sanity.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ARM Beowolf Cluster</title>
      <link>http://simonwillshire.com/papers/Odroid-ARM-Cluster/</link>
      <pubDate>Sat, 27 Feb 2016 15:47:17 -0500</pubDate>
      
      <guid>http://simonwillshire.com/papers/Odroid-ARM-Cluster/</guid>
      <description>

&lt;h2 id=&#34;original-course-paper-2014:c46ac4fdbf68a53eba8d65cea4fdd9c8&#34;&gt;Original Course Paper (2014)&lt;/h2&gt;

&lt;p&gt;This paper was writted for an operating systems course (COIS-3320H) in 2014. It analyses the ARM big.LITTLE architecture and scheduling algorithms. The paper documents
the steps in order to create an Odroid beowolf cluster (Single board ARM computers) and set up messaging using MPICH3 and a central NFS storage.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://simonwillshire.com/files/OS_ARM_Cluster.pdf&#34;&gt;ARM Beowolf Cluster (PDF)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Efficient Parallelism</title>
      <link>http://simonwillshire.com/papers/efficient-parallelism/</link>
      <pubDate>Sat, 27 Feb 2016 15:37:18 -0500</pubDate>
      
      <guid>http://simonwillshire.com/papers/efficient-parallelism/</guid>
      <description>

&lt;h2 id=&#34;original-course-paper-2015:6fb25818af042e5977668bb6cf3ef47d&#34;&gt;Original Course Paper (2015)&lt;/h2&gt;

&lt;p&gt;This paper was written for a distributed computer course (COIS-4350H) in 2015. It analyses the Parallela architecture using ARM and it&amp;rsquo;s MIMD coprocessor (Epiphany).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://simonwillshire.com/files/DC_Paper_Parallela.pdf&#34;&gt;Efficient Parallelism (PDF)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>